package sqlgen

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"regexp"
	"strings"
)

const (
	tab                = "    "
	comma              = ","
	goTimeStampType    = "Timestamp"
	unsupportedTypeAlt = "TEXT"
	commonPackage      = "common"
)

// GenerateDownFile generates a sql file for migrate down.
func GenerateDownFile(gen *protogen.Plugin, file *protogen.File, fileName, packageName, owner, contractName, version string) {
	if fileName == "" {
		fileName = file.GeneratedFilenamePrefix
	}

	filename := fileName + ".down.sql"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("-- Code generated by protoc-gen-sql. Feel free to modify it as you see fit.")
	g.P()

	genDropTables(g, file, packageName, owner, contractName, version)
}

// GenerateUpFile generates a sql file for migrate up.
func GenerateUpFile(gen *protogen.Plugin, file *protogen.File, fileName, packageName, owner, contractName, version string) {
	if fileName == "" {
		fileName = file.GeneratedFilenamePrefix
	}

	filename := fileName + ".up.sql"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("-- Code generated by protoc-gen-sql. Feel free to modify it as you see fit.")
	g.P()
	genCreateTables(g, file, packageName, owner, contractName, version)
}

func genCreateTables(g *protogen.GeneratedFile, file *protogen.File, packageName, owner, contractName, version string) {
	for _, msg := range file.Messages {
		tn := genTableName(file, msg, packageName, owner, contractName, version)
		g.P("CREATE TABLE IF NOT EXISTS ", "\"", tn, "\"", " (")
		genDefaultCols(g)
		genTableContent(g, msg)
		g.P(");")
		genIndices(g, msg, tn)
		g.P()
	}
}

func genIndices(g *protogen.GeneratedFile, msg *protogen.Message, tn string) {
	for _, field := range msg.Fields {
		if checkLeadingComment(field) {
			g.P("CREATE INDEX ON ", "\"", tn, "\"", " (", "\"", field.Desc.Name(), "\"", ");")
		}
	}
}

func genDefaultCols(g *protogen.GeneratedFile) {
	g.P(tab, "ns TEXT NOT NULL", comma)
	g.P(tab, "s TEXT NOT NULL", comma)
}

func genTableContent(g *protogen.GeneratedFile, msg *protogen.Message) {
	for i, field := range msg.Fields {
		if i < len(msg.Fields)-1 {
			g.P(tab, "\"", field.Desc.Name(), "\"", " ", fieldSqlType(g, field), comma)
		} else {
			g.P(tab, "\"", field.Desc.Name(), "\"", " ", fieldSqlType(g, field))
		}
	}
}

func genTableName(file *protogen.File, msg *protogen.Message, packageName, owner, contractName, version string) string {
	path := strings.Trim(string(file.GoImportPath), "\"")
	path = strings.ReplaceAll(path, "/", ".")

	if packageName != "" || owner != "" {
		path = owner + "." + packageName
	}
	path = strings.Trim(path, ".")

	if packageName == commonPackage {
		path = commonPackage
	}
	fs := "%s.%s.%s.%s"
	if contractName == "" {
		fs = "%s.%s.%s%s"
	}

	return strings.ToLower(fmt.Sprintf(fs, path, version, contractName, msg.GoIdent.GoName))
}

func genDropTables(g *protogen.GeneratedFile, file *protogen.File, packageName, owner, contractName, version string) {
	for _, msg := range file.Messages {
		g.P("DROP TABLE IF EXISTS ", "\"", genTableName(file, msg, packageName, owner, contractName, version), "\"", ";")
	}
}

// fieldSqlType returns the Go type used for a field.
func fieldSqlType(g *protogen.GeneratedFile, field *protogen.Field) (sqlType string) {
	sqlType = checkTrailingComment(field)
	if sqlType != "" {
		return sqlType
	}

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		sqlType = "BOOLEAN"
	case protoreflect.EnumKind:
		sqlType = unsupportedTypeAlt
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		sqlType = "INT4"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		sqlType = "INT8"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		sqlType = "INT8"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		sqlType = "INT8"
	case protoreflect.FloatKind:
		sqlType = "FLOAT4"
	case protoreflect.DoubleKind:
		sqlType = "FLOAT8"
	case protoreflect.StringKind:
		sqlType = "TEXT"
	case protoreflect.BytesKind:
		sqlType = "BYTEA"
	case protoreflect.MessageKind:
		goType := g.QualifiedGoIdent(field.Message.GoIdent)
		if strings.Contains(goType, goTimeStampType) {
			sqlType = "TIMESTAMPTZ NOT NULL"
		} else {
			sqlType = unsupportedTypeAlt
		}
	}
	switch {
	case field.Desc.IsList():
		return sqlType + "[]"
	case field.Desc.IsMap():
		sqlType = unsupportedTypeAlt
	}
	return sqlType
}

func checkLeadingComment(field *protogen.Field) bool {
	lc := field.Comments.Leading

	return strings.Contains(string(lc), "index")
}

func checkTrailingComment(field *protogen.Field) string {
	tc := field.Comments.Trailing

	if tc == "" {
		return ""
	}
	bits, unsigned := getBits(string(tc))
	return bitsToNumeric(bits, unsigned)
}

func getBits(comment string) (string, bool) {
	idx := strings.Index(comment, "int")
	if idx == -1 {
		return "", false
	}
	unsigned := false
	if idx == 0 || comment[idx-1:idx] == "u" {
		unsigned = true
	}
	re := regexp.MustCompile("[0-9]+")
	bits := re.FindString(comment[idx:])

	return bits, unsigned
}

func bitsToNumeric(bits string, unsigned bool) string {
	switch bits {
	case "256":
		return "NUMERIC(78,0)"
	case "248":
		return "NUMERIC(75,0)"
	case "240":
		return "NUMERIC(73,0)"
	case "232":
		return "NUMERIC(70,0)"
	case "224":
		return "NUMERIC(68,0)"
	case "216":
		return "NUMERIC(66,0)"
	case "208":
		return "NUMERIC(63,0)"
	case "200":
		return "NUMERIC(61,0)"
	case "192":
		return "NUMERIC(58,0)"
	case "184":
		return "NUMERIC(56,0)"
	case "176":
		return "NUMERIC(53,0)"
	case "168":
		return "NUMERIC(51,0)"
	case "160":
		return "NUMERIC(49,0)"
	case "152":
		return "NUMERIC(46,0)"
	case "144":
		return "NUMERIC(44,0)"
	case "136":
		return "NUMERIC(41,0)"
	case "128":
		return "NUMERIC(39,0)"
	case "120":
		return "NUMERIC(37,0)"
	case "112":
		return "NUMERIC(34,0)"
	case "104":
		return "NUMERIC(32,0)"
	case "96":
		return "NUMERIC(29,0)"
	case "88":
		return "NUMERIC(27,0)"
	case "80":
		return "NUMERIC(25,0)"
	case "72":
		return "NUMERIC(22,0)"
	case "40", "48", "56", "64":
		return "INT8"
	case "32":
		if unsigned {
			return "INT8"
		}
		return "INT4"
	case "24":
		return "INT4"
	case "16":
		// uint16 maps to INT4 in postgres
		if unsigned {
			return "INT4"
		}
		return "INT2"
	case "8":
		return "INT2"
	default:
		return ""
	}
}
